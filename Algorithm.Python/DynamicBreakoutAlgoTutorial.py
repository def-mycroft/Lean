"""Dynamic Breakout II Strategy

Taken circa 21K19 from [this page][1] (pdf file [here][2]). The below is copied
from the web page. 

The code gotten is not the same as the tutorial, tutorial is using a different
signal. 

################################################################################
In this tutorial we will take a close look at the Dynamic Breakout II strategy
based on the book Building Winning Trading Systems.

First we decide the look-back period based on the change rate of volatility,
then we make trading decisions based on the highest high and lowest low from the
look back period as well as a Bollinger Bands indicator. It is an auto adaptive
trading system that can adjust its buy and sell rules depending on the
performance of these rules in the past. In addition to Forex markets it is
widely used in future and equity markets. You can refer to this video to learn
more about dynamic break out II.

The original Dynamic Break Out system was developed by George Pruitt for Futures
Magazine in 1996. The logic behind the dynamic breakout system is that the
volatility component changes the lookback period, then the enter and exit points
are decided by the highest high and lowest low price over the lookback period.
The newer version of the Dynamic Break Out is just like the original, except we
introduce the Bollinger Band and adjust the number of look back days using the
market volatility, so different market conditions perform better with different
parameters. In addition, the stop loss signal is fixed in version one, but in
version two the liquidate point is based on the moving average indicator and the
length of moving average is dynamically changed with the look-back period.

We backtested the strategy on EURUSD and GBPUSD over 6 years period.  The result
suggests a drawdown of 20% and the strategy caught the market turning points. It
is especially profitable in a trending market.

# Step 1: Determine the look back periods

The lookback period is the number of bars back from the most recent bar that the
price or indicator looks at to make the momentum calculations. To start the look
back period is set to 20 days to determine its buy and sell levels. We change
the number of look back days in proportion to changes in market volatility.
Through this method the number of look back days changes on a daily basis. At
the end of each day, the current market volatility is calculated by the standard
deviation of the past 30 day's closing prices.

```
close = self.History(self.syl, 31, Resolution.Daily)['close']
   todayvol = np.std(close[1:self.numdays+1])
   yesterdayvol = np.std(close[0:self.numdays])
   deltavol = (todayvol - yesterdayvol) / todayvol
   self.numdays = round(self.numdays * (1 + deltavol)) # days must be int
```

Though the look back days are dynamic, it needs to be restricted within an
acceptable range of 20 to 60.

# Step 2: Choose the algorithm buy/sell point

For a buy setup, the close price of the previous day must be above the upper
Bollinger Band. In addition the ask price must be above the highest high of the
most recent N days. Where N is the look back days from Step-1. For a sell setup,
the close price of previous day must be below the lower Bollinger Band and the
ask price must be below the lowest low of the most recent N days. The length of
the Bollinger Band calculation is the same number of look back days that is
generated by Step-1.

Bollinger Band is a popular technical indicator. k is a constant. Here we choose
k=2.

    UpperBand=moving average+k×standard deviation
    LowerBand=moving average−k×standard deviation

QuantConnect provides more than 100 technical indicators for you to use in your
algorithm. These are provided as class objects in Python. A full list of the
indicators and their properties can be found in the reference table of the
documentation page.

```
self.bolband = self.BB(self.syl,self.numdays, decimal.Decimal(2), 
                       MovingAverageType.Exponential,Resolution.Daily)
     self.upband = self.bolband.UpperBand
     self.lowband = self.bolband.LowerBand
```

# Step 3: Choose the algorithm liquidation point

The exit signal for an existing holding is determined by calculating a simple
moving average of closing prices for the past look back days. That is to say, we
liquidate a long position if the current price is lower than the moving average
of the close price over the look back period, and vice versa for selling a short
position.

```
self.buypoint = max(self.high)
self.sellpoint = min(self.low)
historyclose = self.History(self.syl, self.numdays, Resolution.Daily)['close']
self.longLiqPoint = np.mean(historyclose)
self.shortLiqPoint = np.mean(historyclose)
self.yesterdayclose = historyclose.iloc[-1]
```

# Conclusion

For six years backtesting of EURUSD, the overall statistics show an annual rate
of return of 2.3% and with a Sharpe Ratio of 0.31. EURUSD has a significant
uptrend from 2010 to 2012. This momentum strategy outperforms the market and
seems to be profitable from 2010 to 2014.  The maximum drawdown occurs in May
2015 to December 2015 and is roughly 14%. From our results we find the strategy
works best in an trending forex market.

In contrast, GBPUSD is pretty volatile during the tested period from 2010 to
2016. Our testing demonstrated a negative annual rate of return with a drawdown
of approximately 19%. When the volatility decreases, the price tends to continue
following the current trend. Volatility causes the the look back days to
decrease when computing the bollinger bands, making it easier to enter a trade.
If the market volatility increases we increase the look back days in order to
filter the fake signals, making it harder to enter a trade.

Here we use the standard deviation of price as a measure of market volatility.
To improve the model we could choose other measures of volatility like standard
deviation of logarithm return series or other stochastic volatility measures.

# References

George Pruitt, John R. Hill, Michael Russak (September 2012). Building Winning
Trading Systems, page 126,  Online Copy

Robert C. Miner(October 20, 2008). High Probability Trading Strategies: Entry to
Exit Tactics for the Forex, Futures, and Stock Markets, page 37,  Online Copy

################################################################################

[1]:https://www.quantconnect.com/tutorials/strategy-library/the-dynamic-breakout-ii-strategy
[2]:https://drive.google.com/file/d/1qNUNfZYG_lG91pIpLXbdv-CMrCDE4swW/view?usp=sharing

"""
from datetime import datetime
import decimal
import numpy as np


class DynamicBreakoutAlgorithm(QCAlgorithm):
    
    def Initialize(self):
        self.SetStartDate(2010,1,15)
        self.SetEndDate(2016,2,15)
        self.SetCash(100000)
        fx = self.AddForex("EURUSD", Resolution.Hour, Market.Oanda)
        self.syl = fx.Symbol
        self.Schedule.On(self.DateRules.EveryDay(self.syl),
                         self.TimeRules.BeforeMarketClose(self.syl, 1),
                         Action(self.SetSignal))
        self.numdays = 20
        self.ceiling, self.floor = 60, 20
        self.buypoint, self.sellpoint = None, None
        self.longLiqPoint, self.shortLiqPoint, self.yesterdayclose = \
            None, None, None
        self.SetBenchmark(self.syl)
        # TODO - what is the BB property? assume from QCAlgorithm? 
        self.Bolband = self.BB(self.syl, self.numdays, 2, 
                               MovingAverageType.Simple, Resolution.Daily)
        # NOTE that this is not the same as the tutorial, would have the below:
        #self.upband = self.bolband.UpperBand
        #self.lowband = self.bolband.LowerBand
   
    def SetSignal(self):
        
        # get close price data 
        close = self.History(self.syl, 31, Resolution.Daily)['close']
        # calculate std of window including today... 
        todayvol = np.std(close[1:31])
        # ...and calculate std of window shifted by 1 unit
        yesterdayvol = np.std(close[0:30])
        # calculate the percentage change in std 
        chg_std_pct = (todayvol - yesterdayvol) / todayvol
        # the number of days is multiplied by 1+chg_std_pct
        self.numdays = int(round(self.numdays * (1 + chg_std_pct)))

        # make sure that numdays is within the limits (defined in init)
        if self.numdays > self.ceiling:
           self.numdays = self.ceiling
        elif self.numdays < self.floor:
            self.numdays = self.floor
        
        # create variables for daily high price and daily low price
        self.high = \
            self.History(self.syl, self.numdays, Resolution.Daily)['high']
        self.low = \
            self.History(self.syl, self.numdays, Resolution.Daily)['low']      

        # set buy and sell points, stop loss levels 
        self.buypoint = max(self.high)
        self.sellpoint = min(self.low)
        historyclose = self.History(self.syl, self.numdays, 
                                    Resolution.Daily)['close'] 
        self.longLiqPoint = np.mean(historyclose)
        self.shortLiqPoint = np.mean(historyclose)
        self.yesterdayclose = historyclose.iloc[-1]
        
        # wait for our BollingerBand to fully initialize
        if not self.Bolband.IsReady: return

    
        # TODO - this doesn't need to be evaluated if there is a position
        ## initiate long position as needed 
        close_above_upper_band = \
            self.yesterdayclose > self.Bolband.UpperBand.Current.Value
        price_above_buy_point = \
            self.Portfolio[self.syl].Price >= self.buypoint
        # if closed above band yesterday and still there...
        if close_above_upper_band and price_above_buy_point:
            # ... purchase 1 unit 
            self.SetHoldings(self.syl, 1)

        ## initiate short position as needed 
        close_below_lower_band = \
            self.yesterdayclose < self.Bolband.LowerBand.Current.Value
        price_below_sell_point = \
            self.Portfolio[self.syl].Price <= self.sellpoint
        # if closed below band yesterday and still there...
        elif close_below_lower_band and price_below_sell_point:
            # ...sell 1 unit 
            self.SetHoldings(self.syl, -1)

        ## exit at risk points as needed 
        holdings = self.Portfolio[self.syl].Quantity
        price_below_long_stop = \
            # TODO - this appears to be a bug, should be longLiqPoint
            self.Portfolio[self.syl].Price <= self.longLiqPoint
        # if long and price_below_long_stop, exit position 
        if holdings > 0 and price_below_long_stop:
            self.Liquidate(self.syl)
        # if short and price_above_short_stop, exit position 
        price_above_short_stop = \
            self.Portfolio[self.syl].Price >= self.shortLiqPoint
        elif holdings < 0 and price_above_short_stop:
            self.Liquidate(self.syl)
      
        self.Log(str(self.yesterdayclose)+(" # of days ")+(str(self.numdays)))
        
    def OnData(self,data):
        pass
